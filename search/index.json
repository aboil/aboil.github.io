[{"content":"十大经典排序算法总结 参考自：https://www.cnblogs.com/guoyaohua/p/8600214.html\n[TOC]\n前言 排序算法说明 排序的定义 对一序列对象根据某个关键字进行排序。\n术语说明\n 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面； 不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面； 内排序：所有排序操作都在内存中完成； 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 时间复杂度： 一个算法执行所耗费的时间。 空间复杂度：运行完一个程序所需内存的大小。  算法总结 \r\rimg\r\n图片名词解释：\n n: 数据规模 k: “桶”的个数 In-place: 占用常数内存，不占用额外内存 Out-place: 占用额外内存  算法分类 \r\rimg\r\n\r\rimg\r\n比较和非比较的区别   常见的快速排序、归并排序、堆排序、冒泡排序等属于比较排序。在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。\n在冒泡排序之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在归并排序、快速排序之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均O(nlogn)。 比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。\n  计数排序、基数排序、桶排序则属于非比较排序。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。 非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。 非比较排序时间复杂度低，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。\n  1、冒泡排序（Bubble Sort） 冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。\n1.1 算法描述  比较相邻的元素。如果第一个比第二个大，就交换它们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 重复步骤 1~3，直到排序完成。  1.2 代码实现 public static int[] bubbleSort(int[] array) { if (array.length == 0) return array; for (int i = 0; i \u0026lt; array.length; i++) for (int j = 0; j \u0026lt; array.length - 1 - i; j++) if (array[j + 1] \u0026lt; array[j]) { int temp = array[j + 1]; array[j + 1] = array[j]; array[j] = temp; } return array; } 1.3 算法分析 最佳情况：$T(n) = O(n)$ 最差情况：$T(n) = O(n^2)$ 平均情况：$T(n) = O(n^2)$\n2、选择排序（Selection Sort） 表现最稳定的排序算法之一，因为无论什么数据进去都是 $O(n^2)$ 的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。\n选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\n2.1 算法描述 n个记录的直接选择排序可经过 n-1 趟直接选择排序得到有序结果。具体算法描述如下：\n 初始状态：无序区为R[1..n]，有序区为空； 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区； n-1趟结束，数组有序化了。  2.2 代码实现 public static int[] selectionSort(int[] array) { if (array.length == 0) return array; for (int i = 0; i \u0026lt; array.length; i++) { int minIndex = i; for (int j = i; j \u0026lt; array.length; j++) { if (array[j] \u0026lt; array[minIndex]) //找到最小的数  minIndex = j; //将最小数的索引保存  } int temp = array[minIndex]; array[minIndex] = array[i]; array[i] = temp; } return array; } 2.3 算法分析 最佳情况：$T(n) = O(n^2)$ 最差情况：$T(n) = O(n^2)$ 平均情况：$T(n) = O(n^2)$\n3、插入排序（Insertion Sort） 插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用 in-place 排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。\n3.1 算法描述 一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：\n 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。  3.2 动图演示 \r\rimg\r\n3.3 代码实现 public static int[] insertionSort(int[] array) { if (array.length == 0) return array; int current; for (int i = 0; i \u0026lt; array.length - 1; i++) { current = array[i + 1]; int preIndex = i; while (preIndex \u0026gt;= 0 \u0026amp;\u0026amp; current \u0026lt; array[preIndex]) { array[preIndex + 1] = array[preIndex]; preIndex--; } array[preIndex + 1] = current; } return array; } 3.3 算法分析 最佳情况：$T(n) = O(n^2)$ 最差情况：$T(n) = O(n^2)$ 平均情况：$T(n) = O(n^2)$\n4、希尔排序（Shell Sort） 希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破 $O(n^2)$ 的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。\n希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。\n4.1 算法描述 我们来看下希尔排序的基本步骤，在此我们选择增量 gap=length/2，缩小增量继续以 gap = gap/2 的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2...1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。\n先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：\n 选择一个增量序列 t1，t2，…，tk，其中 ti\u0026gt;tj，tk=1； 按增量序列个数k，对序列进行k 趟排序； 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。  4.2 过程演示 \r\rimg\r\n动态图：\n\r\rimg\r\n4.3 代码实现 public static int[] ShellSort(int[] array) { int len = array.length; int temp, gap = len / 2; while (gap \u0026gt; 0) { for (int i = gap; i \u0026lt; len; i++) { temp = array[i]; int preIndex = i - gap; while (preIndex \u0026gt;= 0 \u0026amp;\u0026amp; array[preIndex] \u0026gt; temp) { array[preIndex + gap] = array[preIndex]; preIndex -= gap; } array[preIndex + gap] = temp; } gap /= 2; } return array; } 4.4 算法分析 最佳情况：$T(n) = O(nlog_2 n)$ 最坏情况：$T(n) = O(nlog_2 n) $ 平均情况：$T(n) =O(nlog_2n)$　5、归并排序（Merge Sort） 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。\n5.1 算法描述  把长度为n的输入序列分成两个长度为n/2的子序列； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列。  5.2 动图演示 \r\rimg\r\n5.3 代码实现 public static int[] MergeSort(int[] array) { if (array.length \u0026lt; 2) return array; int mid = array.length / 2; int[] left = Arrays.copyOfRange(array, 0, mid); int[] right = Arrays.copyOfRange(array, mid, array.length); return merge(MergeSort(left), MergeSort(right)); } /** * 归并排序——将两段排序好的数组结合成一个排序数组 * * @param left * @param right * @return */ public static int[] merge(int[] left, int[] right) { int[] result = new int[left.length + right.length]; for (int index = 0, i = 0, j = 0; index \u0026lt; result.length; index++) { // i是遍历left的指针，j是遍历right的指针  if (i \u0026gt;= left.length) result[index] = right[j++]; else if (j \u0026gt;= right.length) result[index] = left[i++]; else if (left[i] \u0026gt; right[j]) result[index] = right[j++]; else result[index] = left[i++]; } return result; } 6、快速排序（Quick Sort） 快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。\n6.1 算法描述 快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：\n 从数列中挑出一个元素，称为 “基准”（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。  6.2 代码实现 public static int[] QuickSort (int[] arr) { // write code here  quick(arr, 0, arr.length-1); return arr; } public static void quick(int[] list, int left, int right){ if(left\u0026lt;right){ int point = partition(list, left, right); quick(list, left, point-1); quick(list, point+1, right); } } public static int partition(int[] list, int left, int right){ int temp = list[right]; int point = left-1; for(int i=left; i\u0026lt;right; i++){ if(list[i]\u0026lt;temp){ point ++; swap(list, point, i); } } swap(list, point+1, right); return point + 1; } public static void swap(int[] list, int i, int j){ int temp = list[i]; list[i] = list[j]; list[j] = temp; } 7、堆排序（Heap Sort） 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。\n7.1 算法描述  将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区； 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]\u0026lt;=R[n]； 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。  7.2 动图演示 \r\rimg\r\n7.3 代码实现 注意：这里用到了完全二叉树的部分性质：详情见《数据结构二叉树知识点总结》\n//声明全局变量，用于记录数组array的长度； static int len; /** * 堆排序算法 * * @param array * @return */ public static int[] HeapSort(int[] array) { len = array.length; if (len \u0026lt; 1) return array; //1.构建一个最大堆  buildMaxHeap(array); //2.循环将堆首位（最大值）与末位交换，然后在重新调整最大堆  while (len \u0026gt; 0) { swap(array, 0, len - 1); len--; adjustHeap(array, 0); } return array; } /** * 建立最大堆 * * @param array */ public static void buildMaxHeap(int[] array) { //从最后一个非叶子节点开始向上构造最大堆  for (int i = (len/2 - 1); i \u0026gt;= 0; i--) { //感谢 @让我发会呆 网友的提醒，此处应该为 i = (len/2 - 1)  adjustHeap(array, i); } } /** * 调整使之成为最大堆 * * @param array * @param i */ public static void adjustHeap(int[] array, int i) { int maxIndex = i; //如果有左子树，且左子树大于父节点，则将最大指针指向左子树  if (i * 2 \u0026lt; len \u0026amp;\u0026amp; array[i * 2] \u0026gt; array[maxIndex]) maxIndex = i * 2; //如果有右子树，且右子树大于父节点，则将最大指针指向右子树  if (i * 2 + 1 \u0026lt; len \u0026amp;\u0026amp; array[i * 2 + 1] \u0026gt; array[maxIndex]) maxIndex = i * 2 + 1; //如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。  if (maxIndex != i) { swap(array, maxIndex, i); adjustHeap(array, maxIndex); } } 8、计数排序（Counting Sort） 计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。\n计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。\n8.1 算法描述  找出待排序的数组中最大和最小的元素； 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。  8.2 动图演示 \r\rimg\r\n8.3 代码实现 public static int[] CountingSort(int[] array) { if (array.length == 0) return array; int bias, min = array[0], max = array[0]; for (int i = 1; i \u0026lt; array.length; i++) { if (array[i] \u0026gt; max) max = array[i]; if (array[i] \u0026lt; min) min = array[i]; } bias = 0 - min; int[] bucket = new int[max - min + 1]; Arrays.fill(bucket, 0); for (int i = 0; i \u0026lt; array.length; i++) { bucket[array[i] + bias]++; } int index = 0, i = 0; while (index \u0026lt; array.length) { if (bucket[i] != 0) { array[index] = i - bias; bucket[i]--; index++; } else i++; } return array; } 8.4 算法分析 当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。\n最佳情况：T(n) = O(n+k) 最差情况：T(n) = O(n+k) 平均情况：T(n) = O(n+k)\n9、桶排序（Bucket Sort） 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。\n桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排\n9.1 算法描述  人为设置一个BucketSize，作为每个桶所能放置多少个不同数值（例如当BucketSize==5时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放100个3）； 遍历输入数据，并且把数据一个一个放到对应的桶里去； 对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序； 从不是空的桶里把排好序的数据拼接起来。  注意，如果递归使用桶排序为各个桶排序，则当桶数量为1时要手动减小BucketSize增加下一循环桶的数量，否则会陷入死循环，导致内存溢出。\n9.2 图片演示 \r\rimage-20210421165321590\r\n9.3 代码实现 public static ArrayList\u0026lt;Integer\u0026gt; BucketSort(ArrayList\u0026lt;Integer\u0026gt; array, int bucketSize) { if (array == null || array.size() \u0026lt; 2) return array; int max = array.get(0), min = array.get(0); // 找到最大值最小值  for (int i = 0; i \u0026lt; array.size(); i++) { if (array.get(i) \u0026gt; max) max = array.get(i); if (array.get(i) \u0026lt; min) min = array.get(i); } int bucketCount = (max - min) / bucketSize + 1; ArrayList\u0026lt;ArrayList\u0026lt;Integer\u0026gt;\u0026gt; bucketArr = new ArrayList\u0026lt;\u0026gt;(bucketCount); ArrayList\u0026lt;Integer\u0026gt; resultArr = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; bucketCount; i++) { bucketArr.add(new ArrayList\u0026lt;Integer\u0026gt;()); } for (int i = 0; i \u0026lt; array.size(); i++) { bucketArr.get((array.get(i) - min) / bucketSize).add(array.get(i)); } for (int i = 0; i \u0026lt; bucketCount; i++) { if (bucketSize == 1) { // 如果带排序数组中有重复数字时 感谢 @见风任然是风 朋友指出错误  for (int j = 0; j \u0026lt; bucketArr.get(i).size(); j++) resultArr.add(bucketArr.get(i).get(j)); } else { if (bucketCount == 1) bucketSize--; ArrayList\u0026lt;Integer\u0026gt; temp = BucketSort(bucketArr.get(i), bucketSize); for (int j = 0; j \u0026lt; temp.size(); j++) resultArr.add(temp.get(j)); } } return resultArr; } 9.4 算法分析 桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。\n最佳情况：$T(n) = O(n+k)$ 最差情况：$T(n) = O(n+k)$ 平均情况：$T(n) = O(n^2)$\n10、基数排序（Radix Sort） 基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；\n基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。\n10.1 算法描述  取得数组中的最大数，并取得位数； arr为原始数组，从最低位开始取每个位组成radix数组； 对radix进行计数排序（利用计数排序适用于小范围数的特点）；  10.2 动图演示 \r\rimg\r\n10.3 代码实现 public static int[] RadixSort(int[] array) { if (array == null || array.length \u0026lt; 2) return array; // 1.先算出最大数的位数；  int max = array[0]; for (int i = 1; i \u0026lt; array.length; i++) { max = Math.max(max, array[i]); } int maxDigit = 0; while (max != 0) { max /= 10; maxDigit++; } int mod = 10, div = 1; ArrayList\u0026lt;ArrayList\u0026lt;Integer\u0026gt;\u0026gt; bucketList = new ArrayList\u0026lt;ArrayList\u0026lt;Integer\u0026gt;\u0026gt;(); for (int i = 0; i \u0026lt; 10; i++) bucketList.add(new ArrayList\u0026lt;Integer\u0026gt;()); for (int i = 0; i \u0026lt; maxDigit; i++, mod *= 10, div *= 10) { for (int j = 0; j \u0026lt; array.length; j++) { int num = (array[j] % mod) / div; bucketList.get(num).add(array[j]); } int index = 0; for (int j = 0; j \u0026lt; bucketList.size(); j++) { for (int k = 0; k \u0026lt; bucketList.get(j).size(); k++) array[index++] = bucketList.get(j).get(k); bucketList.get(j).clear(); } } return array; } 10.4 算法分析 最佳情况：T(n) = O(n * k) 最差情况：T(n) = O(n * k) 平均情况：T(n) = O(n * k)\n基数排序有两种方法：\nMSD 从高位开始进行排序 LSD 从低位开始进行排序\n基数排序 vs 计数排序 vs 桶排序 这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：\n 基数排序：根据键值的每位数字来分配桶 计数排序：每个桶只存储单一键值 桶排序：每个桶存储一定范围的数值  ","date":"2021-01-21T17:13:07+08:00","permalink":"https://aboil.github.io/p/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/","title":"十大经典排序算法总结"},{"content":"关于我\n\r\r\n","date":"2020-11-16T22:50:54+08:00","image":"https://aboil.github.io/p/%E7%9F%A5%E4%BD%A0%E6%89%80%E6%83%B3/index.assets/inco_navigation_hu0963947b4e14f1a839ab34753934aacf_72527_120x120_fill_q75_box_smart1.jpg","permalink":"https://aboil.github.io/p/%E7%9F%A5%E4%BD%A0%E6%89%80%E6%83%B3/","title":"知你所想"},{"content":"开始前的准备\n   安装hugo\t（下面有介绍）\n  安装配置好git\n  准备好github账号\n  Markdown编辑器：如Typora\n   1、安装Hugo hugo算是免安装的，简单来说就行下载安装包，解压后，将其主程序所在的路径加到环境变量中即可。\n 安装包下载地址： GitHub 仓库 找到相应版本下载即可。我使用的是 hugo_extended_0.78.2_Windows-64bit.zip 这个版本。下载解压后，将其主程序所在的路径添加到 Windows 的系统环境变量的 PATH 中即可，不需安装。 验证：在cmd窗口中输入：hugo version，会出现一行类似：Hugo Static Site Generator v0.78.2/extended windows/amd64 BuildDate: unknown 就表明安装正确。  Hugo官网： https://gohugo.io Hugo中文文档： https://www.gohugo.org/\n2、创建站点 在工作目录下按下右键，选择右键菜单中的 Git Bash Here，创建一个名为 myblogsite 的站点，输入以下指令：\n$ hugo new site myblogsite $ cd myblogsite 3、添加主题Themes hugo有很多主题模板，可以下载一个，地址为：https://themes.gohugo.io/  ，这里我选择的是Stack 主题（地址）。\n用git命令将主题下载到 myblogsite/themes/hugo-theme-stack/目录下：\n$ git clone https://github.com/CaiJimmy/hugo-theme-stack.git themes/hugo-theme-stack 或者直接下载下来，将其解压到myblogsite/themes/hugo-theme-stack/目录下也可以。\n用下载主题里的myblogsite\\themes\\hugo-theme-stack\\exampleSite\\config.toml配置文件替换根目录下myblogsite\\config.toml文件\n设置config.toml里属性theme: \u0026quot;hugo-theme-stack\u0026quot;\n==tips：==如果用的也是我这个主题，要注意仔细阅读这个主题的说明文档。\n4、创建博客 在站点的根目录下，这里是myblogsite/使用以下命令：\n$ hugo new post/index.md 创建的index.md文档路径是myblogsite/content/post/index.md\n用Typora编辑器打开该index.md文档，将下面代码重新写在index.md文档中：\n+++ author = \u0026#34;aboil\u0026#34; title = \u0026#34;我的测试\u0026#34; date = 2020-11-16T15:38:53+08:00 description = \u0026#34;该博客的摘要\u0026#34; categories = [ \u0026#34;Test\u0026#34; ] tags = [ \u0026#34;emoji\u0026#34;, ] image = \u0026#34;test01.jpg\u0026#34; math = true +++ 正文部分 其中：\n  date 指定的是日期\n  categories 指定的是该博文的所属分类，多个要用逗号隔开\n  tags 指定的是该博文的标签，多个要用逗号隔开\n  image 指定的是该博文的预览图\n  math 如果本文中插入的有数学公式，可以设置该字段为true，\n  5、本地调试 在站点根目录下myblogsite/执行下面指令\n$ hugo server -t hugo-theme-stack --buildDrafts 其中hugo-theme-stack是自己下载的主题的名字\n\r\r\n浏览器中访问：localhost:1313/ 即可\n6、部署到github上 创建github仓库 新建一个github仓库，设置为public,仓库名与账号同名。如你的github名为abc，则将该仓库命名为abc.github.io，\n部署 将站点部署到abc.github.io仓库中\n将根目录下config.toml文件中baseURL改为https://abc.github.io/\n在站点根目录执行hugo命令生成/public文件夹。public下存放的就是所有静态页面，只需要把public目录里面的文件push到你的仓库就好\n$ hugo --theme=hugo-theme-stack --baseUrl=\u0026quot;https://abc.github.io/\u0026quot; --buildDrafts 该命令后，站点目录下会生成一个public文件夹，下面只需要将public文件夹push到abc.github.io仓库中即可\n# 进入public文件夹内 $ cd public/ $ git init $ git add . $ git commit -m \u0026quot;描述信息，如：创建我的个人主页\u0026quot; # 第一次需要与远程项目建立链接： $ git remote add origin https://github.com/aboil/aboil.github.io.git # 直接 git push 不行的话，就用下面这个 $ git push -u origin master\t之后只需要访问网址https://abc.github.io即可\n__tips:__如果还是没看懂，可以在B站上找个教学视频看看，我当时看了这个：B站-手把手教你从0开始搭建自己的个人博客 |第二种姿势 | hugo\n","date":"2020-11-16T17:09:51+08:00","permalink":"https://aboil.github.io/p/%E5%9F%BA%E4%BA%8Ehugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5/","title":"基于hugo搭建个人主页"},{"content":"问题描述 在没有安装Code Runner插件时，运行的代码是在 终端窗口 执行的，执行结果没有出现中文乱码。 \r\r 安装完Code Runner插件后，运行结果会切换到在 输出窗口 显示执行结果，同时会出现中文乱码问题，如下： \r\r 下面有三种解决方法都能解决，推荐最后一种方法。\n解决方法1 简言之，把执行结果再切换回终端窗口执行， 设置方法是在 设置 中勾选Run In Terminal即可。再次运行时，执行结果会在 终端窗口 显示。 \r\r 个人不太喜欢这种方法，还是喜欢想PyCharm那样在输出窗口显示执行结果，下面两种方法亲测可用，个人最喜欢最后一种解决方法。\n解决方法2 简言之是在 python 代码的开头加上以下代码：\n# -*-coding:utf-8 -*- import io import sys sys.stdout=io.TextIOWrapper(sys.stdout.buffer,encoding=\u0026#39;utf8\u0026#39;) \r\r\n解决方法3 简言之在setting.json中修改配置信息。 找到 python 并设置 set PYTHONIOENCODING=utf8 \u0026amp;\u0026amp; python，过程如下：\n 首先打开setting.json文件。 \r\r 然后修改python的编码格式：set PYTHONIOENCODING=utf8 \u0026amp;\u0026amp; python  \r\r\n 再来看运行结果  \r\r\n","date":"2020-10-11T15:38:53+08:00","permalink":"https://aboil.github.io/p/%E8%A7%A3%E5%86%B3vs-code%E5%AE%89%E8%A3%85code-runner%E6%8F%92%E4%BB%B6%E5%90%8E%E8%BE%93%E5%87%BA%E7%AA%97%E5%8F%A3%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98python/","title":"解决VS Code安装Code Runner插件后，输出窗口中文乱码问题（Python）"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用  思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n 图片 \r\rPhoto by Florian Klauer on Unsplash\r \r\rPhoto by Luca Bravo on Unsplash\r\n\r\rPhoto by Helena Hertz on Unsplash\r \r\rPhoto by Hudai Gayiran on Unsplash\r\n![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://aboil.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_120x120_fill_q75_box_smart1.jpg","permalink":"https://aboil.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.— Rob Pike1 Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Italics Bold Code     italics bold code    Code Blocks Code block with backticks \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r Code block with Hugo\u0026rsquo;s internal highlight shortcode \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Fruit  Apple Orange Banana   Dairy  Milk Cheese    Other Elements — abbr, sub, sup, kbd, mark GIFis a bitmap image format.\nH2O\nXn+ Yn= ZnPress CTRL+ALT+Deleteto end the session.\nMost salamandersare nocturnal, and hunt for insects, worms, and other small creatures.\n  The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015. \u0026#x21a9;\u0026#xfe0e;\n  ","date":"2019-03-11T00:00:00Z","image":"https://aboil.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://aboil.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\n Exierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude  Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\n Comas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et  Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://aboil.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu958d513eeefe5556a31d065479ecc5ac_14205_120x120_fill_q75_box_smart1.jpg","permalink":"https://aboil.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\n Create a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so:  {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }}  To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files  Note: Use the online reference of Supported TeX Functions\nExamples Block math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","date":"2019-03-08T00:00:00Z","permalink":"https://aboil.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\n N.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n.emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; }","date":"2019-03-05T00:00:00Z","image":"https://aboil.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_huf941de4769045cdfa8c9ee7036519a2a_35369_120x120_fill_q75_box_smart1.jpg","permalink":"https://aboil.github.io/p/emoji-support/","title":"Emoji Support"}]